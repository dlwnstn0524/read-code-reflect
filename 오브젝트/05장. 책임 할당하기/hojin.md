# 05장. 책임 할당하기

# 들어가며

4장에서 데이터 중심의 접근법을 취할 경우 직면하는 문제점들을 살펴보았다.

데이터 중심 설계로 인해 발생하는 문제점을 해결하는 **가장 기본적인 방법은 책임에 초점**을 맞추는 것이다.

이번 장에서는 **GRASP 패턴**을 알아보며, 책임 할당의 어려움을 해결하는 답을 제시한다.

# 1. 책임 주도 설계를 향하여

데이터 중심 설계에서 책임 중심 설계로 향하기 위해 아래 원칙을 따르자.

### 데이터보다 행동을 먼저 결정한다.

객체에게 중요한 것은 데이터가 아니라 외부에 제공하는 행동이다.

책임 중심 vs 데이터 중심 설계 질문의 순서

| **구분** | **데이터 중심 설계** | **책임 주도 설계** |
| --- | --- | --- |
| **핵심 초점** | 데이터와 그 데이터를 처리하는 절차(오퍼레이션)에 초점 | 객체가 수행해야 할 책임과 역할에 초점 |
| **질문 순서** | 1. 포함해야 하는 데이터는 무엇인가?  2. 데이터를 처리하기 위한 필요한 오퍼레이션은? | 1. 객체가 수행해야 할 책임은? 
2. 책임을 수행하는 데 필요한 데이터는? |
| **설계 접근 방식** | **데이터 구조를 먼저 정의**하고, 이를 기반으로 필요한 기능을 설계 | **객체의 역할과 책임을 먼저 정의**하고, 이를 수행하기 위해 필요한 데이터를 설계 |

### 협력이라는 문맥 안에서 책임을 결정한다.

좋은 책임이란?

- 객체의 입장에서 책임이 어색해 보이더라도 협력에 적합하다면 좋은 책임이다.

협력에 적합한 책임을 수확하기 위해서는

- 메시지를 결정한 후에 객체를 선택해야 한다.
- ***“메시지를 전송해야 하는데 누구에게 전송하지?”*** 라고 질문하는 것부터 시작하자.

메시지는 전송자 입장에서 결정하는데, 이는 수신자 입장에서 캡슐화되는 효과를 얻는다.

- 메시지 송신자가 수신자에 대한 어떤 가정도 하지 않기 때문이다.

---

# 2. 책임 할당을 위한 GRASP 패턴

GRASP 패턴이란?

- 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙들의 집합을 패턴 형식으로 정리한 것.

### 책임 할당의 출발 - 도메인 개념

설계를 시작하는 단계에서 개념들의 의미와 관계가 완벽할 필요가 없다.

![image](https://github.com/user-attachments/assets/4dc47c46-7ca6-436d-b88b-a242ca0f5b00)


**중요한 것은 설계를 시작하는 것**이지, 도메인 개념들을 완벽하게 정리하는 것이 아니다.

### INFORMATION EXPERT 패턴

객체에서 책임을 할당하는 첫 번째 원칙은 **책임을 수행할 정보를 알고 있는 객체에게 책임을 할당**하는 것이다.

- 이를 **GRASP 패턴에서는 INFORMATION EXPERT 패턴**이라 부른다.

해당 패턴에서는 책임을 수행하는데 필요한 정보를 객체가 알고 있다고 해서 **저장하고 있을 필요는 없다.**

- 데이터에 따른 객체의 상태가 이르게 확정될 필요가 없다.

앞선 장에서 협력 중심의 설계는 연쇄적인 메시지 요청의 과정을 포함했다.

![image 1](https://github.com/user-attachments/assets/e83478cd-c555-47d9-bd4a-61ed8fa7a426)


책임 할당 패턴으로 자율성 높은 객체들로 구성된 협력 공동체를 구축하기 위한 시도로 보아도 무방하다.

그렇다면, 자율성 높은 객체 설계를 위해 고려해야할 다른 것은 무엇인가?

### 응집도와 결합도

올바른 책임 할당을 위해 응집도와 결합도 관점 역시 고려 대상이다.

좋은 설계를 위해 낮은 결합,높은 응집도가 필요하다.

**GRASP에서는 LOW COUPLING, HIGH COHESION**이라 부른다.

**LOW COUPLING 패턴**

- 설계의 전체적인 결합도를 낮게 유지되도록 책임을 할당한다.

**HIGH COHESION 패턴**

- 높은 응집도를 유지할 수 있게 책임을 할당한다.

나쁜 예시로, Screening에서 할인 여부 판단 메시지를 전송하여 결과를 Movie 메시지에 담아 요청하는 과정을 보자.

![image 2](https://github.com/user-attachments/assets/76beda43-974a-42fd-809c-236240437526)


해당 설계가 응집/결합도 과점에서 나쁜 이유는 아래와 같다.

- 응집도 관점 : 할인 여부 판단에 필요한 필드를 Screening에서 필요로 한다. 이는, 할인 조건이 알고 있는 데이터를 Screening에서 조회한다는 뜻이다.
- 결합도 관점 : 할인 여부 판단 방식이 변경되면, Screening도 수정되어야 한다.

### POLYMORPHISM 패턴

객체의 타입에 따라 변하는 행동이 있다면, 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하는 패턴이다.

- 공통 행동을 역할로 격상하여, 각기 다른 구현체에서 책임을 구현한다.

### PROTECTED VARIATIONS 패턴

변동성이 있는 요소와 안정적인 요소 사이에 안정된 인터페이스를 두는 설계 원칙이다.

- **변경으로부터 시스템 요소를 보호하기 위한 목적**을 가진다.

![객체_지향_캡슐화 drawio](https://github.com/user-attachments/assets/38368281-11a3-4c48-95ff-81a94845e4e9)


- 해당 예시처럼, 공통 메시지를 인터페이스로 올리고, 변경을 캡슐화 함으로써 유연한 설계에 한걸음 다가갈 수 있게 된다.

---

# 3. 구현을 통한 검증

나쁜 응집도, 결합도를 가진 설계는 변경에 취약한 구조를 가진다.

이를 구현을 통해 검증해보자.

### 낮은 응집도 개선

- DiscountCondition 객체 구현

```java
public class DiscountCondition {
    private DiscountConditionType type;
    private int sequence;

    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public boolean isSatisfiedBy(Screening screening) {
        if (type == DiscountConditionType.PERIOD) {
            return isSatisfiedByPeriod(screening);
        }

        return isSatisfiedBySequence(screening);
    }

    private boolean isSatisfiedByPeriod(Screening screening) {
        return this.dayOfWeek.equals(screening.getWhenScreened().getDayOfWeek()) &&
                this.startTime.compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
                this.endTime.compareTo(screening.getWhenScreened().toLocalTime()) >=0;

    }

    private boolean isSatisfiedBySequence(Screening screening) {
        return screening.getSequence() == sequence;
    }
}

```

위 DiscountCondition의 변경의 이유가 다양한데, 이것에서 오는 단점이 있다.

**1. 새로운 할인 조건 추가**

- isSatisfiedBy 메서드 내 if ~ else 구문을 수정해야 한다.

**2. 순번 조건 판단 로직 변경**

- sequence 속성 및 isSatisfiedBySequence 메서드가 수정되어야 한다.

**3. 기간 조건 판단 로직 변경**

- 날짜 속성 및 isSatisfiedByPeriod 메서드가 수정되어야 한다.

DiscountConditon은 하나 이상의 변경 이유를 가지기 때문에 응집도가 낮다.

- 서로 연관성 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐져 있음을 의미한다.

응집도가 낮음을 판단하는 방법은 두 가지가 있다.

**1. 인스턴스 변수 초기화 시점**

- 변수들이 서로 다른 시점에 초기화 된다면 응집도가 낮다는 증거이다.

**2. 메서드들의 인스턴스 변수 사용 방식**

- 모든 메서드가 모든 변수를 사용하고 있지 않다면, 응집도가 낮다는 증거이다.

DiscountCondition 객체는 두 가지 단점을 모두 가지고 있다.

이를 다형성을 활용해 개선해보자.

할인 조건의 **동일한 책임을 공통 메시지로 정의하기 위해 역할 개념을 도입**한다.

![image 3](https://github.com/user-attachments/assets/0272c1a7-da9d-40db-bc69-8560a956d0ae)


역할을 사용하여 객체의 구체 타입을 추상화하였다.

이로써, Movie는 메시지 수신자의 구체적인 구현을 몰라도 요금 계산을 요청하는데 지장이 없게 된다.

![image 4](https://github.com/user-attachments/assets/ab02caba-4626-4235-8043-91b37423b843)


---

# 4. 책임 주도 설계의 대안

경험이 쌓인 숙련된 설계자조차 적절한 책임과 객체를 선택하는 일에 어려움을 느낀다고 한다.

해당 저서의 필자는 다음과 같이 조언한다.

- 책임과 객체 사이에서 방황할 때 돌파구를 찾는 방법은 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것이다.
- 코드 상에서 명확히 드러나는 책임들을 올바른 위치로 이동시킨다.

이렇게, 코드를 작성하며 설계를 변경하는 과정이 있게 된다.

**겉으로 드러나는 동작의 변화 없이 내부 구조를 변경하는 것을 리팩터링**이라고 부른다.

흔히 리팩터링이 필요한 상황은 **긴 메서드**라고 볼 수 있다.

긴 메서드가 코드의 보수에 미치는 부정적 영향은 아래와 같다.

| **문제점** | **설명** |
| --- | --- |
| 한눈에 파악하기 어려움 | 메서드가 길어지면 **전체 흐름을 빠르게 이해하기 어렵다.** |
| 너무 많은 일을 처리함 | **단일 책임 원칙을 위반**하여 역할이 모호해지고 유지보수가 어려워진다. |
| 버그 발생 가능성 증가 | 하나의 변경이 메서드 전체에 영향을 미쳐 **오류 가능성이 커진다.** |
| 로직 재사용의 어려움 | 부분 로직을 분리하지 않아 다른 곳에서 **재사용할 수 없다.** |

긴 메서드는 응집도가 낮을 가능성이 높은데,

메서드 역시 클래스처럼 응집도가 높은 방향으로 작성되어야 한다.

응집도가 높은 메서드를 작성하는데 고려되어야 할 사항들은 아래와 같다.

| **고려할 사항** | **기대 효과** |
| --- | --- |
| 코드를 **작은 메서드로 분할**한다 | - 전체적인 흐름을 이해하기 쉬워진다. - 재사용성이 높아진다. |
| 메서드가 **하나의 이유에서만 변경되도록** 한다 | - 버그 발생 소지를 줄여, 변경하기 쉬워진다. |

---

# 5. 마무리

이렇게 책임을 할당하는데 고려할 사항들 및 GRASP 패턴에 대해 알아보았다.

올바른 책임 할당을 위한 과정을 요약하면 아래와 같다.

- **책임 주도 설계**는 데이터보다 행동과 협력을 우선하며, GRASP 패턴으로 책임 할당을 최적화.
- **INFORMATION EXPERT, LOW COUPLING, HIGH COHESION**으로 유연한 설계 구현.
- **다형성과 역할**로 변경 캡슐화, 응집도↑ 결합도↓.
- **리팩터링**으로 긴 메서드 분할, 코드 가독성과 유지보수성 향상.

감사합니다.
