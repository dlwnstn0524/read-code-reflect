# Chapter02

# 0. 들어가며

본 장에서는 리팩터링 전반에 적용되는 원칙 몇가지를 알아가는 시간을 가진다.

---

# 1. 리팩터링 정의

리팩터링란?

- 명사 : 소프트웨어의 **겉보기 동작은 그대로 유지**한 채, 코드를 **이해하고 수정하기 쉽도록 내부 구조를 변경**하는 기법
- 동사(하다) : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 리팩터링 기법을 적용해서 소프트웨어를 재구성한다.

겉보기 동작이라는 표현이 등장하는데 사용자 관점에서 달라지는 점이 없음을 뜻한다.

정리해보면 리팩터링은

프로그램의 **전반적인 기능은 유지하며, 코드를 이해하고 수정하기 쉽게 만드는 것**이다.

---

# 2. 리팩터링은 왜 할까?

설계, 이해, 개발 속도의 관점에서 리팩터링을 왜 진행하는지 알아보자.

### 2-1. 설계 관점

규칙적인 리팩터링은 코드의 구조를 지탱해주는 효과를 준다.

- 코드 구조가 무너지기 시작하면, 코드만으로 설계를 파악하기 어려워진다.
- 파악하기 어려워진 설계는 수정하기 어려워진다.

### 2-2. 이해의 관점

프로그래밍은 마치 컴퓨터와 대화하는 것과 같다.

하지만 개발자 입장에서도 코드와 의사소통한다는 점을 잊지 말아야한다.

- 프로그램 동작에만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못하게 된다.

개발자가 코드를 쉽게 이해한다는 것은, 버그를 쉽게 찾을 수 있다는 말이기도 하다.

- 코드 동작을 확실하게 이해하면, 버그 수정에 대한 두려움도 적어진다.

### 2-3. 개발 속도의 관점

꾸준히 리팩토링되어 코드 베이스가 잘 관리된 소프트웨어는 새 기능을 빠르게 추가할 수 있다.

![image](https://github.com/user-attachments/assets/02382b22-c96c-456b-b535-25560ed6d1d6)

- 내부 설계가 잘된 소프트웨어는 새 기능을 추가할 지점을 쉽게 찾을 수 있다.

**내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대**가 되는데,

저자는 이를 설계 지구력 가설이라고 부른다.

---

# 3. 언제 리팩터링을 할까?

저자는 기회가 될때만 수행하는 3가지 리팩터링을 아래와 같이 제시하고 있다.

### 3-1. 준비를 위한 리팩터링

코드베이스에 기능을 새로 추가하기 직전에 수행하는 리팩터링이다.

- 새 기능 추가 시점에 다른 작업을 하기 훨씬 쉽게 할만한 구조 변경점을 찾는다.

이는 기능을 쉽게 추가하게 만드는 목적으로 수행하는데,

함수 매개변수화하기 방법을 예시로 들 수 있다.

예시) 조건에 따라 숫자 합을 계산하는 코드

```java
public static int sumEven(List<Integer> numbers) {
        int sum = 0;
        for (Integer number : numbers) {
            if (number % 2 == 0) {
                sum += number;
            }
        }
        return sum;
    }

    public static int sumOdd(List<Integer> numbers) {
        int sum = 0;
        for (Integer number : numbers) {
            if (number % 2 != 0) {
                sum += number;
            }
        }
        return sum;
    }
```

위 예시에서 더 많은 숫자 필터링 조건이 등장한다면, 함수가 중복으로 등장하게 된다.

이때 함수 매개변수화 리팩터링을 수행하여 아래와 같이 중복을 제거할 수 있다.

- 숫자 필터링 조건을 Predicate 매개변수에 전달한다.

```java
public static int sumNumbers(List<Integer> numbers, Predicate<Integer> predicate) {
        int sum = 0;
        for (Integer number : numbers) {
            if (predicate.test(number)) {
                sum += number;
            }
        }
        return sum;
    }
```

### 3-2. 이해를 위한 리팩터링

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야만 한다.

이때, 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.

만약, 어떤 역할을 하는지 명확하게 이해되지 않는 변수는

네이밍 변경으로 사용 의도를 더 명확히 드러내도록 할 수 있다.

### 3-3. 쓰레기 줍기 리팩터링

캠핑 규칙처럼, 코드를 처음 봤을 때마다 깔끔하게 정리하고 떠나자는 의미이다.

개발을 진행하는 시점에서의 리팩터링인데,

간단히 수정할 수 있다면 즉시 수정하고, 오래 걸린다면 기록해 두고, 먼저 하던 일을 끝내고 나서 수행하는 방식이다.

수시로 리팩터링하는 방식이다.

---

# 4. 리팩터링 시 고려할 문제

### 4-1. 새 기능 개발 속도 저하

- 리팩터링은 코드 개선에 시간을 소모하므로 단기적으로 새 기능 개발 속도를 늦출 수 있다.

        특히, 관리자가 리팩터링의 가치를 이해하지 못하면 "불필요한 작업"으로 오해할 수 있다.

- 어떻게 해결할 수 있을까?
    - 작은 단계로 리팩터링을 진행해 단기적인 시간 손실을 최소화한다.
    - 관리자에게 리팩터링이 장기적으로 개발 효율성을 높이고 버그를 줄인다고 설득한다……

### 4-2. 브랜치 통합 주기

- 리팩터링이 장기 브랜치에서 진행되면, 메인 브랜치와의 통합 시 충돌 위험이 커진다.
- 어떻게 해결할 수 있을까?
    - 리팩터링을 작은 단위로 나누고, 자주 메인 브랜치에 통합한다.
    - CI/CD 파이프라인을 활용해 브랜치 통합 시 자동 테스트를 실행한다. (충돌 조기 발견 목적)
    - 팀원과 코드 리뷰를 통해 리팩터링 변경 사항을 공유한다.

### 4-3. 테스팅

- 리팩터링은 코드의 외부 동작을 변경하지 않아야 하지만, 테스트가 부족하면 실수로 버그를 도입할 수 있다.
- 어떻게 해결할 수 있을까?
    - 리팩터링 전에, **테스트 스위트를 작성하여 기존 동작을 보장**한다.
    - 리팩터링 후 매 단계마다 테스트를 실행해 안정성을 확인한다.
    - 테스트 커버리지를 점진적으로 늘려 레거시 코드의 리팩터링 위험을 줄인다.

---

# 5. 마무리하며

이번 장에서는 리팩터링의 필요성 및 주의사항에 대해 알아보는 시간을 가졌다.

1장과 마찬가지로 저자는 이해하기 쉬운 코드의 효용성을 여러 차례 강조하고 있다.

본인 역시 실제 업무에서 코드 변경에 따른 버그가 예측하기 어려운 경우 수정에 어려움을 겪거나 

작업을 피하고 싶어하는 모습을 자주 보인다.

아래 격언을 생각하며, 내가 담당하게된 시스템의 코드도 더 이해하기 좋은 구조로 만들 수 있도록 노력해야겠다

***“캠핑장에 도착했을 때보다 깔끔하게 정돈하고 떠난다”***

감사합니다.
